<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skybreak</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #87CEEB; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="game"></canvas>
    <script>
    // ============================================================
    //  SKYBREAK — Core Engine + Advanced Movement
    // ============================================================

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // ── Input Handler ───────────────────────────────────────────
    const keys = {};
    const justPressed = {};
    window.addEventListener('keydown', e => {
        if (!keys[e.code]) justPressed[e.code] = true;
        keys[e.code] = true;
        e.preventDefault();
    });
    window.addEventListener('keyup', e => {
        keys[e.code] = false;
        e.preventDefault();
    });

    function isLeft()  { return keys['ArrowLeft']  || keys['KeyA']; }
    function isRight() { return keys['ArrowRight'] || keys['KeyD']; }
    function isJump()  { return keys['ArrowUp']    || keys['KeyW'] || keys['Space']; }
    function isDash()  { return keys['ShiftLeft']   || keys['ShiftRight'] || keys['KeyJ']; }

    function consumeJump() {
        const pressed = justPressed['ArrowUp'] || justPressed['KeyW'] || justPressed['Space'];
        justPressed['ArrowUp'] = false;
        justPressed['KeyW'] = false;
        justPressed['Space'] = false;
        return pressed;
    }

    function consumeDash() {
        const pressed = justPressed['ShiftLeft'] || justPressed['ShiftRight'] || justPressed['KeyJ'];
        justPressed['ShiftLeft'] = false;
        justPressed['ShiftRight'] = false;
        justPressed['KeyJ'] = false;
        return pressed;
    }

    // ── Player Physics ────────────────────────────────────────────
    const PHYSICS = {
        GRAVITY:        0.85,
        JUMP_FORCE:    -14,
        MOVE_SPEED:     1.0,
        MAX_SPEED_X:    7,
        FRICTION:       0.88,
        PLAYER_W:       28,
        PLAYER_H:       40,

        // Advanced movement
        WALL_SLIDE_SPEED:  2.5,
        WALL_JUMP_FORCE_X: 8,
        WALL_JUMP_FORCE_Y: -13,
        DASH_SPEED:        18,
        DASH_DURATION:     8,
        DASH_COOLDOWN:     45,
        MAX_JUMPS:         2,
    };

    // ── Player ──────────────────────────────────────────────────
    const player = {
        x: 200,
        y: 200,
        vx: 0,
        vy: 0,
        w: PHYSICS.PLAYER_W,
        h: PHYSICS.PLAYER_H,
        onGround: false,
        facing: 1,

        // Advanced movement state
        jumpCount: 0,
        onWall: 0,       // -1 = wall on left, 1 = wall on right, 0 = no wall
        wallSliding: false,
        dashTimer: 0,
        dashCooldown: 0,
        dashDir: 0,
    };

    // ── Particle System ─────────────────────────────────────────
    const particles = [];

    function spawnParticles(x, y, count, color, spread, speed) {
        for (let i = 0; i < count; i++) {
            particles.push({
                x: x + (Math.random() - 0.5) * spread,
                y: y + (Math.random() - 0.5) * spread,
                vx: (Math.random() - 0.5) * speed,
                vy: (Math.random() - 0.5) * speed - 1,
                life: 20 + Math.random() * 20,
                maxLife: 20 + Math.random() * 20,
                size: 2 + Math.random() * 3,
                color: color,
            });
        }
    }

    function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.05;
            p.life--;
            if (p.life <= 0) particles.splice(i, 1);
        }
    }

    function drawParticles() {
        for (const p of particles) {
            const alpha = p.life / p.maxLife;
            ctx.globalAlpha = alpha;
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x - camera.x, p.y - camera.y, p.size, p.size);
        }
        ctx.globalAlpha = 1;
    }

    // ── Platforms / Level ───────────────────────────────────────
    const platforms = [
        // Ground
        { x: -500, y: 500, w: 4000, h: 60, color: '#4a7c3f' },
        // Grass top layer
        { x: -500, y: 492, w: 4000, h: 12, color: '#6abf4b' },

        // Platforms to jump between
        { x: 300,  y: 400, w: 120, h: 20, color: '#8B6914' },
        { x: 500,  y: 320, w: 120, h: 20, color: '#8B6914' },
        { x: 720,  y: 260, w: 150, h: 20, color: '#8B6914' },
        { x: 950,  y: 320, w: 100, h: 20, color: '#8B6914' },
        { x: 1100, y: 250, w: 140, h: 20, color: '#8B6914' },

        // Higher platforms
        { x: 1300, y: 180, w: 100, h: 20, color: '#8B6914' },
        { x: 1500, y: 130, w: 160, h: 20, color: '#8B6914' },
        { x: 1750, y: 200, w: 120, h: 20, color: '#8B6914' },

        // Floating islands
        { x: 2000, y: 350, w: 200, h: 30, color: '#6abf4b' },
        { x: 2300, y: 280, w: 180, h: 30, color: '#6abf4b' },
        { x: 2600, y: 220, w: 220, h: 30, color: '#6abf4b' },

        // Tall walls for wall-jump testing
        { x: 1900, y: 200, w: 30, h: 300, color: '#7a7a7a' },
        { x: 2050, y: 150, w: 30, h: 350, color: '#7a7a7a' },

        // Wall-jump corridor
        { x: 2800, y: 100, w: 30, h: 400, color: '#7a7a7a' },
        { x: 2920, y: 100, w: 30, h: 400, color: '#7a7a7a' },
        // Reward platform at top of corridor
        { x: 2790, y: 80, w: 170, h: 20, color: '#D4AF37' },

        // Dash gap challenge
        { x: 3100, y: 400, w: 120, h: 20, color: '#8B6914' },
        { x: 3400, y: 400, w: 120, h: 20, color: '#8B6914' },
    ];

    // ── Camera ──────────────────────────────────────────────────
    const camera = {
        x: 0,
        y: 0,
        smoothing: 0.08,
    };

    function updateCamera() {
        const targetX = player.x + player.w / 2 - canvas.width / 2;
        const targetY = player.y + player.h / 2 - canvas.height / 2 + 50;

        camera.x += (targetX - camera.x) * camera.smoothing;
        camera.y += (targetY - camera.y) * camera.smoothing;
    }

    // ── Collision Detection ─────────────────────────────────────
    function rectOverlap(a, b) {
        return a.x < b.x + b.w &&
               a.x + a.w > b.x &&
               a.y < b.y + b.h &&
               a.y + a.h > b.y;
    }

    function checkWallContact() {
        player.onWall = 0;
        const wallProbe = 2;

        for (const plat of platforms) {
            // Check right side
            const rightProbe = {
                x: player.x + player.w,
                y: player.y + 4,
                w: wallProbe,
                h: player.h - 8
            };
            if (rectOverlap(rightProbe, plat) && !player.onGround) {
                player.onWall = 1;
                return;
            }

            // Check left side
            const leftProbe = {
                x: player.x - wallProbe,
                y: player.y + 4,
                w: wallProbe,
                h: player.h - 8
            };
            if (rectOverlap(leftProbe, plat) && !player.onGround) {
                player.onWall = -1;
                return;
            }
        }
    }

    function resolveCollisions() {
        player.onGround = false;

        for (const plat of platforms) {
            if (!rectOverlap(player, plat)) continue;

            const overlapLeft   = (player.x + player.w) - plat.x;
            const overlapRight  = (plat.x + plat.w) - player.x;
            const overlapTop    = (player.y + player.h) - plat.y;
            const overlapBottom = (plat.y + plat.h) - player.y;

            const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

            if (minOverlap === overlapTop && player.vy >= 0) {
                player.y = plat.y - player.h;
                player.vy = 0;
                player.onGround = true;
            } else if (minOverlap === overlapBottom && player.vy < 0) {
                player.y = plat.y + plat.h;
                player.vy = 0;
            } else if (minOverlap === overlapLeft) {
                player.x = plat.x - player.w;
                player.vx = 0;
            } else if (minOverlap === overlapRight) {
                player.x = plat.x + plat.w;
                player.vx = 0;
            }
        }
    }

    // ── Update ──────────────────────────────────────────────────
    function update(dt) {
        // ── Dash ────────────────────────────────────────────────
        if (player.dashCooldown > 0) player.dashCooldown--;

        if (consumeDash() && player.dashCooldown <= 0 && player.dashTimer <= 0) {
            player.dashTimer = PHYSICS.DASH_DURATION;
            player.dashCooldown = PHYSICS.DASH_COOLDOWN;
            player.dashDir = player.facing;
            player.vy = 0;
            spawnParticles(
                player.x + player.w / 2,
                player.y + player.h / 2,
                12, '#FFD700', 10, 4
            );
        }

        if (player.dashTimer > 0) {
            player.dashTimer--;
            player.vx = PHYSICS.DASH_SPEED * player.dashDir;
            player.vy = 0;
            // Dash trail particles
            if (player.dashTimer % 2 === 0) {
                spawnParticles(
                    player.x + player.w / 2 - player.dashDir * 15,
                    player.y + player.h / 2,
                    3, 'rgba(255,215,0,0.8)', 6, 1
                );
            }
            // Skip normal movement during dash
            player.x += player.vx;
            resolveCollisions();
            checkWallContact();
            updateParticles();
            updateCamera();
            return;
        }

        // ── Normal horizontal movement ──────────────────────────
        if (isLeft()) {
            player.vx -= PHYSICS.MOVE_SPEED;
            player.facing = -1;
        }
        if (isRight()) {
            player.vx += PHYSICS.MOVE_SPEED;
            player.facing = 1;
        }

        // Friction
        if (!isLeft() && !isRight()) {
            player.vx *= PHYSICS.FRICTION;
            if (Math.abs(player.vx) < 0.1) player.vx = 0;
        }

        // Clamp horizontal speed
        player.vx = Math.max(-PHYSICS.MAX_SPEED_X, Math.min(PHYSICS.MAX_SPEED_X, player.vx));

        // Gravity
        player.vy += PHYSICS.GRAVITY;

        // ── Wall Slide ──────────────────────────────────────────
        player.wallSliding = false;
        if (player.onWall !== 0 && !player.onGround && player.vy > 0) {
            const pressingIntoWall = (player.onWall === 1 && isRight()) ||
                                     (player.onWall === -1 && isLeft());
            if (pressingIntoWall) {
                player.wallSliding = true;
                player.vy = Math.min(player.vy, PHYSICS.WALL_SLIDE_SPEED);
                // Wall slide particles
                if (Math.random() < 0.3) {
                    const wx = player.onWall === 1 ? player.x + player.w : player.x;
                    spawnParticles(wx, player.y + player.h - 5, 1, '#aaa', 3, 0.5);
                }
            }
        }

        // ── Jump / Double Jump / Wall Jump ──────────────────────
        if (consumeJump()) {
            if (player.wallSliding || (player.onWall !== 0 && !player.onGround)) {
                // Wall jump
                player.vx = PHYSICS.WALL_JUMP_FORCE_X * -player.onWall;
                player.vy = PHYSICS.WALL_JUMP_FORCE_Y;
                player.facing = -player.onWall;
                player.jumpCount = 1;
                player.onWall = 0;
                player.wallSliding = false;
                spawnParticles(
                    player.onWall === 1 ? player.x + player.w : player.x,
                    player.y + player.h / 2,
                    8, '#ccc', 8, 3
                );
            } else if (player.onGround) {
                // Ground jump
                player.vy = PHYSICS.JUMP_FORCE;
                player.onGround = false;
                player.jumpCount = 1;
                spawnParticles(
                    player.x + player.w / 2,
                    player.y + player.h,
                    6, '#b8926a', 12, 2
                );
            } else if (player.jumpCount < PHYSICS.MAX_JUMPS) {
                // Double jump
                player.vy = PHYSICS.JUMP_FORCE * 0.85;
                player.jumpCount++;
                spawnParticles(
                    player.x + player.w / 2,
                    player.y + player.h,
                    8, '#88ccff', 8, 3
                );
            }
        }

        // Apply velocity
        player.x += player.vx;
        player.y += player.vy;

        // Collision
        resolveCollisions();
        checkWallContact();

        // Reset jump count on ground
        if (player.onGround) {
            player.jumpCount = 0;
        }

        // Fall out of world reset
        if (player.y > 800) {
            player.x = 200;
            player.y = 200;
            player.vx = 0;
            player.vy = 0;
            player.jumpCount = 0;
            player.dashTimer = 0;
        }

        updateParticles();
        updateCamera();
    }

    // ── Render ──────────────────────────────────────────────────
    function drawBackground() {
        const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grad.addColorStop(0, '#4A90D9');
        grad.addColorStop(0.6, '#87CEEB');
        grad.addColorStop(1, '#B0E0F0');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Parallax clouds
        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        const cloudOffset = camera.x * 0.3;
        for (let i = 0; i < 8; i++) {
            const cx = (i * 400 + 100) - (cloudOffset % 3200);
            const cy = 60 + (i % 3) * 50;
            drawCloud(cx, cy, 40 + (i % 3) * 20);
        }
    }

    function drawCloud(x, y, size) {
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.arc(x + size * 0.8, y - size * 0.3, size * 0.7, 0, Math.PI * 2);
        ctx.arc(x + size * 1.4, y, size * 0.8, 0, Math.PI * 2);
        ctx.arc(x - size * 0.5, y + size * 0.1, size * 0.6, 0, Math.PI * 2);
        ctx.fill();
    }

    function drawPlatforms() {
        for (const plat of platforms) {
            const sx = plat.x - camera.x;
            const sy = plat.y - camera.y;

            if (sx + plat.w < 0 || sx > canvas.width || sy + plat.h < 0 || sy > canvas.height) continue;

            ctx.fillStyle = plat.color;
            ctx.fillRect(sx, sy, plat.w, plat.h);

            ctx.strokeStyle = 'rgba(0,0,0,0.15)';
            ctx.lineWidth = 1;
            ctx.strokeRect(sx, sy, plat.w, plat.h);
        }
    }

    function drawPlayer() {
        const px = player.x - camera.x;
        const py = player.y - camera.y;

        // Dash afterimage
        if (player.dashTimer > 0) {
            ctx.globalAlpha = 0.3;
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(px - player.dashDir * 12, py, player.w, player.h);
            ctx.globalAlpha = 1;
        }

        // Shadow
        if (player.onGround) {
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.beginPath();
            ctx.ellipse(px + player.w / 2, py + player.h + 2, player.w / 2, 4, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        // Wall slide visual (stretch player slightly)
        const squash = player.wallSliding ? 0.9 : 1;

        // Body
        ctx.fillStyle = player.dashTimer > 0 ? '#FFD700' : '#E84855';
        ctx.fillRect(px + 2, py + 4, player.w - 4, (player.h - 4) * squash);

        // Head area
        ctx.fillStyle = player.dashTimer > 0 ? '#FFE44D' : '#F05A67';
        ctx.fillRect(px + 2, py, player.w - 4, 16);

        // Eyes
        const eyeX = player.facing === 1 ? px + 16 : px + 5;
        ctx.fillStyle = '#fff';
        ctx.fillRect(eyeX, py + 5, 8, 8);
        ctx.fillStyle = '#1a1a2e';
        const pupilX = player.facing === 1 ? eyeX + 4 : eyeX + 1;
        ctx.fillRect(pupilX, py + 7, 3, 4);

        // Feet
        ctx.fillStyle = '#C13040';
        ctx.fillRect(px + 3, py + player.h - 6, 9, 6);
        ctx.fillRect(px + player.w - 12, py + player.h - 6, 9, 6);
    }

    function drawHUD() {
        // Controls hint
        ctx.fillStyle = 'rgba(0, 0, 0, 0.35)';
        ctx.fillRect(10, canvas.height - 65, 360, 55);
        ctx.fillStyle = '#fff';
        ctx.font = '13px monospace';
        ctx.textAlign = 'left';
        ctx.fillText('WASD / Arrows = move   |   Space / W / Up = jump', 20, canvas.height - 45);
        ctx.fillText('Shift / J = dash       |   Double-tap jump mid-air', 20, canvas.height - 20);

        // Title
        ctx.fillStyle = 'rgba(255,255,255,0.8)';
        ctx.font = 'bold 16px monospace';
        ctx.textAlign = 'right';
        ctx.fillText('SKYBREAK', canvas.width - 20, 28);

        // Ability indicators
        const indicatorY = 50;
        ctx.textAlign = 'right';
        ctx.font = '12px monospace';

        // Double jump indicator
        const jumpsLeft = PHYSICS.MAX_JUMPS - player.jumpCount;
        ctx.fillStyle = jumpsLeft > 0 ? '#88ccff' : '#666';
        ctx.fillText(`Jumps: ${'●'.repeat(jumpsLeft)}${'○'.repeat(player.jumpCount)}`, canvas.width - 20, indicatorY);

        // Dash indicator
        const dashReady = player.dashCooldown <= 0 && player.dashTimer <= 0;
        ctx.fillStyle = dashReady ? '#FFD700' : '#666';
        const dashPct = dashReady ? 100 : Math.round((1 - player.dashCooldown / PHYSICS.DASH_COOLDOWN) * 100);
        ctx.fillText(`Dash: ${dashReady ? 'READY' : dashPct + '%'}`, canvas.width - 20, indicatorY + 18);

        // Wall slide indicator
        if (player.wallSliding) {
            ctx.fillStyle = '#aaa';
            ctx.fillText('WALL SLIDE', canvas.width - 20, indicatorY + 36);
        }
    }

    function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBackground();
        drawPlatforms();
        drawParticles();
        drawPlayer();
        drawHUD();
    }

    // ── Game Loop ───────────────────────────────────────────────
    let lastTime = 0;

    function gameLoop(timestamp) {
        const dt = Math.min((timestamp - lastTime) / 16.67, 3);
        lastTime = timestamp;

        update(dt);
        render();

        requestAnimationFrame(gameLoop);
    }

    requestAnimationFrame(gameLoop);

    </script>
</body>
</html>
